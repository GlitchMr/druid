use v6;

# Given a string (assumed to contain no newlines), replaces a section of that
# string, starting from $column, with the contents of $new_section. When
# replacing characters, two excpetions are made: (1) spaces in $new_section
# are treated as 'transparent', so that they don't replace the old character,
# (2) octothorpes '#' insert actual spaces, i.e. act as a sort of escape
# character for spaces.
sub merge($old, $new, $start) {
    my @old = $old.split('');
    my @new = $new.split('');

    # RAKUDO: xx and push don't seem to work as advertised.
    push @old, ' ' for ^($start + $new.chars - $old.chars);

    for @new.kv -> $i, $char {
        @old[$start + $i] = $char unless $char eq ' ';
        @old[$start + $i] = ' ' if $char eq '#'
    }

    return @old.join('');
}


# Given a string representing a piece and one representing the board, returns
# a new board with the piece inserted into some coordinates. This sub assumes
# that pieces are drawn in an order that makes sense, so that pieces in front
# cover those behind.
sub put($piece, $board, $coords) {
    my @lines = $board.split("\n");

    my $layer = substr( $coords, 3 );

    my $line = substr( $coords, 1, 1 );
    my $coord_line = +@lines - 8 - 3 * ($line - 1) - $layer;

    return put($piece, "\n" ~ $board, $coords) if $coord_line < 0;

    my $column = ord( substr($coords, 0, 1).lc ) - ord('a');
    my $coord_column = 3 + 6 * $column + $layer;

    for $piece.split("\n").kv -> $line_no, $piece_line {
        my $board_line = @lines[$coord_line + $line_no];
        @lines[ $coord_line + $line_no ]
            = merge($board_line, $piece_line, $coord_column);
    }

    return @lines.join("\n");
}

# Prints two smaller boards representing (1) who owns each location, and
# (2) how many stones have been piled on each location.
sub print_colors_and_heights(@colors, @heights) {

    my $size = +@colors;

    my &from_pretty    = { $^pretty.trans( ['>>',   '<<', '.']
                                        => ['%2d','%-2d','%s'] ) };

    my &format_colors  = { <. v h>[$^color] };
    my &format_heights = { $^height || '.' };

    my $letters = 'A'..chr(ord('A') + $size - 1);

    my $inter_board_space = ' ' x (1 + 6*$size - 2*$size - 2*($size-1) - 14);
    my $footer = [~] "\n      ", $letters.join(' '),
                     ' ' x 8, $inter_board_space,
                     $letters.join(' '), "\n";
    my $header = "$footer\n";

    my $board_line = [~] '>>  ', ('.' xx $size).join(' '), '  <<';

    print $header;
    for (1..$size).reverse -> $row {
        say sprintf from_pretty(
                [~] '  ', $board_line, $inter_board_space, $board_line
            ),
            $row, (map &format_colors,  @colors[$row-1].values),  $row,
            $row, (map &format_heights, @heights[$row-1].values), $row;
    }
    print $footer;
}

# Reads a string from STDIN, and checks it for validity in various ways.
# As a first check, the move syntax is checked to be either a sarsen move
# or a lintel move. A valid sarsen move must be placed on the ground or on
# stones of the same color. A valid lintel move must cover exactly three
# locations in a row, and the lintel itself must have stones under both
# ends, and two of the maximally three supporting stones must be of the
# placed lintel's color.
sub input_valid_move(@heights, @colors, $color) {

    my &flunk_move = { say $^reason; return };

    my $move = =$*IN;
    say '' and exit(1) if $*IN.eof;

    my $size = +@colors;

    given $move {
        when $sarsen_move {
            my $row = $<coords><row_number> - 1;
            my $column = ord($<coords><col_letter>) - ord('a');

            flunk_move "The highest column is '{chr(ord('A')+$size-1)}'"
                if $column >= $size;
            flunk_move 'There is no row 0'
                if $row == -1;
            flunk_move "There are only $size rows"
                if $row >= $size;

            flunk_move 'Not your spot'
                unless @colors[$row][$column] == 0|$color;
        }

        when $lintel_move {
            my $row_1    = $<coords>[0]<row_number> - 1;
            my $row_2    = $<coords>[1]<row_number> - 1;
            my $column_1 = ord($<coords>[0]<col_letter>) - ord('a');
            my $column_2 = ord($<coords>[1]<col_letter>) - ord('a');

            flunk_move "The highest column is '{chr(ord('A')+$size-1)}'"
                if $column_1|$column_2 >= $size;
            flunk_move 'There is no row 0'
                if $row_1|$row_2 == -1;
            flunk_move "There are only $size rows"
                if $row_1|$row_2 >= $size;

            my $row_diff    = abs($row_1 - $row_2);
            my $column_diff = abs($column_1 - $column_2);

            flunk_move 'Must be exactly two cells apart'
                unless $row_diff == 2 && $column_diff == 0
                    || $row_diff == 0 && $column_diff == 2;

            flunk_move 'Must be supported at both ends'
                unless @heights[$row_1][$column_1]
                    == @heights[$row_2][$column_2];

            my $row_m    = ($row_1    + $row_2   ) / 2;
            my $column_m = ($column_1 + $column_2) / 2;
        
            flunk_move 'There is a piece in the way in the middle'
                unless @heights[$row_m][$column_m]
                    <= @heights[$row_1][$column_1];

            flunk_move 'No lintels on the ground'
                unless @heights[$row_1][$column_1];

            my $number_of_samecolor_supporting_pieces
                = (@colors[$row_1][$column_1] == $color ?? 1 !! 0)
                + (@colors[$row_2][$column_2] == $color ?? 1 !! 0);

            if @heights[$row_m][$column_m] == @heights[$row_1][$column_1] { 
                $number_of_samecolor_supporting_pieces
                    += @colors[$row_m][$column_m] == $color ?? 1 !! 0;
            }

            flunk_move 'Must be exactly two of your pieces under a lintel'
                if $number_of_samecolor_supporting_pieces != 2;
        }

        when $pass {
            # Nothing to do; it's a pass
        }

        default {
            flunk_move '
The move does not conform to the accepted move syntax, which is either
something like "b2" or something like "c1-c3".'.substr(1);
        }
    }

    return $move;
}

# Prints the 3D game board and the two smaller sub boards, reflecting the
# current state of the game.
sub print_board_view(@layers, @colors, @heights) {

    my $board = $empty_board;

    for @layers.kv -> $height, $layer {
        for $layer.kv.reverse -> $line, $row {
            for $line.kv.reverse -> $cell, $column {

                my $move
                    = chr($column + ord('a')) ~ ($row+1) ~ '-' ~ $height;

                $board = do given $cell {
                    when 1  { put( $v_piece, $board, $move ) }
                    when 2  { put( $h_piece, $board, $move ) }
                    default { $board }
                };
            }
        }
    }

    print $board;

    print_colors_and_heights(@colors, @heights);
}

# Analyzes a given move of a piece of a given color, and makes the appropriate
# changes to the given game state data structures. This sub assumes that the
# move is valid.
sub make_move($move, $color, @layers is rw, @colors is rw, @heights is rw) {

    my @pieces_to_put;

    given $move {
        when $sarsen_move {
            my $row = $<coords><row_number> - 1;
            my $column = ord($<coords><col_letter>) - ord('a');
            my $height = @heights[$row][$column];

            @pieces_to_put = $height, $row, $column;
        }

        when $lintel_move {
            my $row_1    = $<coords>[0]<row_number> - 1;
            my $row_2    = $<coords>[1]<row_number> - 1;
            my $column_1 = ord($<coords>[0]<col_letter>) - ord('a');
            my $column_2 = ord($<coords>[1]<col_letter>) - ord('a');
            my $height   = @heights[$row_1][$column_1];
            my $row_m    = ($row_1    + $row_2   ) / 2;
            my $column_m = ($column_1 + $column_2) / 2;

            @pieces_to_put = $height, $row_1, $column_1,
                             $height, $row_m, $column_m,
                             $height, $row_2, $column_2;
        }

        default { die "Nasty syntax."; }
    }

    for @pieces_to_put -> $height, $row, $column {

        my $size = +@colors;
        if $height >= @layers {
            push @layers, [map { [0 xx $size] }, ^$size];
        }
        @layers[$height][$row][$column]
            = @colors[$row][$column]
            = $color;
        @heights[$row][$column] = $height + 1;
    }
}

# RAKUDO: Would like to make this class local to move_was_winning, using
# 'my class', but that is not implemented yet.
class Pos {
    has $.row    is rw;
    has $.column is rw;
    method Str { join ',', $.row, $.column }
}

# Starting from the last move made, traces the chains to determine whether
# the two sides have been connected.
sub move_was_winning($move, @colors) {

    # BUG: There is something wrong with this algorithm for board size 3
    # and the move sequence c1, b2, c3, b2, c1-c3. The last move should
    # register as a winning move, but it doesn't.
    my ($row, $column);
    given $move {
        when $sarsen_move {
            $row    = $<coords><row_number> - 1;
            $column = ord($<coords><col_letter>) - ord('a');
        }
        when $lintel_move {
            $row    = $<coords>[0]<row_number> - 1;
            $column = ord($<coords>[0]<col_letter>) - ord('a');
        }
        default { return False; } # unknown move type
    }

    my @pos_queue = Pos.new( :row($row), :column($column) );

    my $last_color = @colors[$row][$column];
    my $size = +@colors;

    my &above = { .row    < $size - 1 && .clone( :row(.row + 1)       ) };
    my &below = { .row    > 0         && .clone( :row(.row - 1)       ) };
    my &right = { .column < $size - 1 && .clone( :column(.column + 1) ) };
    my &left  = { .column > 0         && .clone( :column(.column - 1) ) };

    my %visited;
    my $reached_one_end   = False;
    my $reached_other_end = False;

    # I can't quite figure out why, but debug statements reveal that the
    # loops test the initial position twice, despite the fact that it's only
    # added to the array once.
    while shift @pos_queue -> $pos {
        ++%visited{~$pos};

        for &above, &below, &right, &left -> &direction {
            my $r = $pos.row;
            my $c = $pos.column;
            if direction($pos) -> $neighbor {

                if !%visited.exists(~$neighbor)
                   && @colors[$neighbor.row][$neighbor.column] == $last_color {

                    push @pos_queue, Pos.new( :row($neighbor.row),
                                              :column($neighbor.column) );
                }
            }
            # RAKUDO: Need to restore the values of $pos this way as long as
            # the .clone bug persists.
            $pos.row = $r;
            $pos.column = $c;
        }

        if    $last_color == 1 && !above($pos)
           || $last_color == 2 && !right($pos) {

            $reached_one_end   = True;
        }
        elsif    $last_color == 1 && !below($pos)
              || $last_color == 2 &&  !left($pos) {

            $reached_other_end = True;
        }

        return True if $reached_one_end && $reached_other_end;
    }

    return False;
}

# Returns a string containing an ASCII picture of an empty druid board of the
# given size.
sub make_empty_board($size) {
    return join "\n", gather {
        take '';
        take my $heading
            = [~] '   ', map { "   $_  " }, map { chr($_+ord('A')) }, ^$size;
        take my $line = [~] '   ', '+-----' x $size, '+';
        for (1..$size).reverse -> $r {
            take [~] (sprintf '%2d |', $r), '      ' x ($size) - 1, "     | $r";
            take [~] '   |', '      ' x ($size) - 1,  '     |';
            if $r > 1 {
                take [~] '   +', '     +' x $size;
            }
        }
        take $line;
        take $heading;
        take '';
    };
}
        

my $v_piece = '
 +-----+
/|#v#v#|
||#v#v#|
|+-----+
/-----/
';

my $h_piece = '
 +-----+
/|#h#h#|
||#h#h#|
|+-----+
/-----/
';

my $board_size = 8;
for @*ARGS -> $argument {
    if $argument ~~ / '--size=' (\d+) / {
        if $0 < (my $MIN_SIZE = 3) {
            say "The board size may not be smaller than $MIN_SIZE.";
            exit(1);
        }
        elsif $0 > (my $MAX_SIZE = 26) {
            say "The board size may not be larger than $MAX_SIZE.";
            exit(1);
        }
        $board_size = +$0;
    }
}

my $empty_board = make_empty_board($board_size);

regex col_letter { <[a..z]> }
regex row_number { \d+ }
regex coords { <col_letter><row_number> }

my $sarsen_move = /^ <coords> $/;
my $lintel_move = /^ <coords> '-' <coords> $/;
my $pass = /^ 'pass' | 'p' $/;

# A three-dimensional array. Each item is a layer in on the board, starting
# from the ground. The number of elements in this array always corresponds to
# the height of a highest stone on the board.
my @layers;

# A two-dimensional array. Records the height of the highest stone on each
# location.
my @heights = map { [ 0 xx $board_size] }, ^$board_size;

# A two-dimensional array. Records the color of the highest stone on each
# location.
my @colors = map { [ 0 xx $board_size] }, ^$board_size;

if any(@*ARGS) eq '--help' {
    # RAKUDO: Heredocs.
    say .substr(4) for split "\n", '
    Druid. Implementation © Carl Mäsak 2008-2009. Rules © Cameron Browne.

    Usage:
        % perl6 druid [switches]

        --size=<size>       Give the board a size between 3 and 26.
        --computer=[1|2]    The computer controls player one or two.
        --help              Display this help text.
    ';

    exit(0);
}

my $play_mode =    (?(any(@*ARGS) eq '--computer=1') && 1)
                +| (?(any(@*ARGS) eq '--computer=2') && 2);

die 'Druid currently does not support computer-vs-computer play.'
    if $play_mode == 3;

my $passes_in_a_row = 0;
loop {
    for <Vertical Horizontal> Z $v_piece, $h_piece Z 1, 2 -> $player,
                                                             $piece,
                                                             $color {

        my $move;
        if $color +& $play_mode { # This player is controlled by the computer
            my ($row, $column);
            repeat {
                $row    = (^$board_size).pick[0];
                $column = (^$board_size).pick[0];
            } until @colors[$row][$column] == 0 | $color;
            $move = chr(ord('a')+$column) ~ ($row+1);

            say "Computer moves $move";
        }
        else {
            print_board_view(@layers, @colors, @heights);

            repeat {
                print "\n", $player, ': '
            } until $move = input_valid_move(@heights, @colors, $color);
        }

        if $move ~~ $pass {
            if ++$passes_in_a_row >= 2 {
                say "It's a draw.";
                exit(0);
            }
            next;
        }
        elsif $move !~~ $pass {
            $passes_in_a_row = 0;
        }

        make_move($move, $color, @layers, @colors, @heights);

        if move_was_winning($move, @colors) {
            print_board_view(@layers, @colors, @heights);
            print "\n";

            say "$player won.";
            exit(0);
        }
    }
}

# vim: filetype=perl6
