use v6;

use Druid::Board;
use Druid::Board::Text;

# Reads a string from STDIN, and checks it for validity in various ways.
# As a first check, the move syntax is checked to be either a sarsen move
# or a lintel move. A valid sarsen move must be placed on the ground or on
# stones of the same color. A valid lintel move must cover exactly three
# locations in a row, and the lintel itself must have stones under both
# ends, and two of the maximally three supporting stones must be of the
# placed lintel's color.
sub input_valid_move(@heights, @colors, $color) {

    my &flunk_move = { say $^reason; return };

    my $move = =$*IN;
    say '' and exit(1) if $*IN.eof;

    my $size = +@colors;

    given $move {
        when $sarsen_move {
            my $row = $<coords><row_number> - 1;
            my $column = ord($<coords><col_letter>) - ord('a');

            flunk_move "The highest column is '{chr(ord('A')+$size-1)}'"
                if $column >= $size;
            flunk_move 'There is no row 0'
                if $row == -1;
            flunk_move "There are only $size rows"
                if $row >= $size;

            flunk_move 'Not your spot'
                unless @colors[$row][$column] == 0|$color;
        }

        when $lintel_move {
            my $row_1    = $<coords>[0]<row_number> - 1;
            my $row_2    = $<coords>[1]<row_number> - 1;
            my $column_1 = ord($<coords>[0]<col_letter>) - ord('a');
            my $column_2 = ord($<coords>[1]<col_letter>) - ord('a');

            flunk_move "The highest column is '{chr(ord('A')+$size-1)}'"
                if $column_1|$column_2 >= $size;
            flunk_move 'There is no row 0'
                if $row_1|$row_2 == -1;
            flunk_move "There are only $size rows"
                if $row_1|$row_2 >= $size;

            my $row_diff    = abs($row_1 - $row_2);
            my $column_diff = abs($column_1 - $column_2);

            flunk_move 'Must be exactly two cells apart'
                unless $row_diff == 2 && $column_diff == 0
                    || $row_diff == 0 && $column_diff == 2;

            flunk_move 'Must be supported at both ends'
                unless @heights[$row_1][$column_1]
                    == @heights[$row_2][$column_2];

            my $row_m    = ($row_1    + $row_2   ) / 2;
            my $column_m = ($column_1 + $column_2) / 2;
        
            flunk_move 'There is a piece in the way in the middle'
                unless @heights[$row_m][$column_m]
                    <= @heights[$row_1][$column_1];

            flunk_move 'No lintels on the ground'
                unless @heights[$row_1][$column_1];

            my $number_of_samecolor_supporting_pieces
                = (@colors[$row_1][$column_1] == $color ?? 1 !! 0)
                + (@colors[$row_2][$column_2] == $color ?? 1 !! 0);

            if @heights[$row_m][$column_m] == @heights[$row_1][$column_1] { 
                $number_of_samecolor_supporting_pieces
                    += @colors[$row_m][$column_m] == $color ?? 1 !! 0;
            }

            flunk_move 'Must be exactly two of your pieces under a lintel'
                if $number_of_samecolor_supporting_pieces != 2;
        }

        when $pass {
            # Nothing to do; it's a pass
        }

        default {
            flunk_move '
The move does not conform to the accepted move syntax, which is either
something like "b2" or something like "c1-c3".'.substr(1);
        }
    }

    return $move;
}

# Analyzes a given move of a piece of a given color, and makes the appropriate
# changes to the given game state data structures. This sub assumes that the
# move is valid.
sub make_move($move, $color, @layers is rw, @colors is rw, @heights is rw) {

    my @pieces_to_put;

    given $move {
        when $sarsen_move {
            my $row = $<coords><row_number> - 1;
            my $column = ord($<coords><col_letter>) - ord('a');
            my $height = @heights[$row][$column];

            @pieces_to_put = $height, $row, $column;
        }

        when $lintel_move {
            my $row_1    = $<coords>[0]<row_number> - 1;
            my $row_2    = $<coords>[1]<row_number> - 1;
            my $column_1 = ord($<coords>[0]<col_letter>) - ord('a');
            my $column_2 = ord($<coords>[1]<col_letter>) - ord('a');
            my $height   = @heights[$row_1][$column_1];
            my $row_m    = ($row_1    + $row_2   ) / 2;
            my $column_m = ($column_1 + $column_2) / 2;

            @pieces_to_put = $height, $row_1, $column_1,
                             $height, $row_m, $column_m,
                             $height, $row_2, $column_2;
        }

        default { die "Nasty syntax."; }
    }

    for @pieces_to_put -> $height, $row, $column {

        my $size = +@colors;
        if $height >= @layers {
            push @layers, [map { [0 xx $size] }, ^$size];
        }
        @layers[$height][$row][$column]
            = @colors[$row][$column]
            = $color;
        @heights[$row][$column] = $height + 1;
    }
}

# RAKUDO: Would like to make this class local to move_was_winning, using
# 'my class', but that is not implemented yet.
class Pos {
    has $.row    is rw;
    has $.column is rw;
    method Str { join ',', $.row, $.column }
}

# Starting from the last move made, traces the chains to determine whether
# the two sides have been connected.
sub move_was_winning($move, @colors) {

    # BUG: There is something wrong with this algorithm for board size 3
    # and the move sequence c1, b2, c3, b2, c1-c3. The last move should
    # register as a winning move, but it doesn't.
    my ($row, $column);
    given $move {
        when $sarsen_move {
            $row    = $<coords><row_number> - 1;
            $column = ord($<coords><col_letter>) - ord('a');
        }
        when $lintel_move {
            $row    = $<coords>[0]<row_number> - 1;
            $column = ord($<coords>[0]<col_letter>) - ord('a');
        }
        default { return False; } # unknown move type
    }

    my @pos_queue = Pos.new( :row($row), :column($column) );

    my $last_color = @colors[$row][$column];
    my $size = +@colors;

    my &above = { .row    < $size - 1 && .clone( :row(.row + 1)       ) };
    my &below = { .row    > 0         && .clone( :row(.row - 1)       ) };
    my &right = { .column < $size - 1 && .clone( :column(.column + 1) ) };
    my &left  = { .column > 0         && .clone( :column(.column - 1) ) };

    my %visited;
    my $reached_one_end   = False;
    my $reached_other_end = False;

    # I can't quite figure out why, but debug statements reveal that the
    # loops test the initial position twice, despite the fact that it's only
    # added to the array once.
    while shift @pos_queue -> $pos {
        ++%visited{~$pos};

        for &above, &below, &right, &left -> &direction {
            my $r = $pos.row;
            my $c = $pos.column;
            if direction($pos) -> $neighbor {

                if !%visited.exists(~$neighbor)
                   && @colors[$neighbor.row][$neighbor.column] == $last_color {

                    push @pos_queue, Pos.new( :row($neighbor.row),
                                              :column($neighbor.column) );
                }
            }
            # RAKUDO: Need to restore the values of $pos this way as long as
            # the .clone bug persists.
            $pos.row = $r;
            $pos.column = $c;
        }

        if    $last_color == 1 && !above($pos)
           || $last_color == 2 && !right($pos) {

            $reached_one_end   = True;
        }
        elsif    $last_color == 1 && !below($pos)
              || $last_color == 2 &&  !left($pos) {

            $reached_other_end = True;
        }

        return True if $reached_one_end && $reached_other_end;
    }

    return False;
}

my $board_size = 8;
for @*ARGS -> $argument {
    if $argument ~~ / '--size=' (\d+) / {
        if $0 < (my $MIN_SIZE = 3) {
            say "The board size may not be smaller than $MIN_SIZE.";
            exit(1);
        }
        elsif $0 > (my $MAX_SIZE = 26) {
            say "The board size may not be larger than $MAX_SIZE.";
            exit(1);
        }
        $board_size = +$0;
    }
}

my Druid::Board $board = Druid::Board::Text.new(:size($board_size));

regex col_letter { <[a..z]> }
regex row_number { \d+ }
regex coords { <col_letter><row_number> }

my $sarsen_move = /^ <coords> $/;
my $lintel_move = /^ <coords> '-' <coords> $/;
my $pass = /^ 'pass' | 'p' $/;

# A three-dimensional array. Each item is a layer in on the board, starting
# from the ground. The number of elements in this array always corresponds to
# the height of a highest stone on the board.
my @layers;

# A two-dimensional array. Records the height of the highest stone on each
# location.
my @heights = map { [ 0 xx $board_size ] }, ^$board_size;

# A two-dimensional array. Records the color of the highest stone on each
# location.
my @colors = map { [ 0 xx $board_size ] }, ^$board_size;

if any(@*ARGS) eq '--help' {
    # RAKUDO: Heredocs.
    say .substr(4) for split "\n", '
    Druid. Implementation © Carl Mäsak 2008-2009. Rules © Cameron Browne.

    Usage:
        % perl6 druid [switches]

        --size=<size>       Give the board a size between 3 and 26.
        --computer=[1|2]    The computer controls player one or two.
        --help              Display this help text.
    ';

    exit(0);
}

my $play_mode =    (?(any(@*ARGS) eq '--computer=1') && 1)
                +| (?(any(@*ARGS) eq '--computer=2') && 2);

die 'Druid currently does not support computer-vs-computer play.'
    if $play_mode == 3;

my $passes_in_a_row = 0;
loop {
    for <Vertical Horizontal> Z 1, 2 -> $player, $color {

        my $move;
        if $color +& $play_mode { # This player is controlled by the computer
            my ($row, $column);
            repeat {
                $row    = (^$board_size).pick[0];
                $column = (^$board_size).pick[0];
            } until @colors[$row][$column] == 0 | $color;
            $move = chr(ord('a')+$column) ~ ($row+1);

            say "Computer moves $move";
        }
        else {
            $board.show();

            repeat {
                print "\n", $player, ': '
            } until $move = input_valid_move(@heights, @colors, $color);
        }

        if $move ~~ $pass {
            if ++$passes_in_a_row >= 2 {
                say "It's a draw.";
                exit(0);
            }
            next;
        }
        elsif $move !~~ $pass {
            $passes_in_a_row = 0;
        }

        make_move($move, $color, @layers, @colors, @heights);
        $board.make_move($move, $color);

        if move_was_winning($move, @colors) {
            $board.show();
            print "\n";

            say "$player won.";
            exit(0);
        }
    }
}

# vim: filetype=perl6
